# 递归

三个层面：

-表现：函数调用自身
-实质：将问题范围进行逐渐减少，收敛的过程
-实现：什么是最小号问题（base case），如何将问题变成最小号问题（recursion rule）

### 前端相关
	
#### Array.prototype.reduce()
#### 深拷贝
#### 数组平拍
#### vuex


### 函数调用栈

- [ ] 动图

- [ ] 前端笔记 link 调用栈溢出

### 核心思想

#### 拆解问题

- 把规模大的问题变成规模较小的同类型问题
- 规模较小的问题又不断变成规模更小的问题
- 规模小到一定程度可以直接得出它的解

#### 求解

- 由最小规模问题的解得出较大规模问题的解
- 由较大规模问题的解不断得出规模更大问题的解
- 最后得出原来问题的解

> 凡是可以利用上述思想解决问题的，都可以尝试使用递归

通常链表、二叉树的问题都可以利用递归思想来解决，因为这两个数据结构本身就是递归的结构：“套娃”。

### 逻辑细分

#### 明确函数的功能

不要去思考里面代码怎么写，首先搞清楚这个函数的干嘛用的

#### 明确原问题与子问题的关系

简单说就是在当前层做点什么事儿，能够将范围不断的缩减，最终缩减到最小号问题。

#### 明确basecase

- 递归的过程中，子问题的规模在不断减小，当小到一定程度时可以直接得出它的解
- 寻找递basecase，相当于是思考这个问题：问题规模小到什么程度可以直接得出解？

#### fibo

#### fibo 优化 - 记忆法
#### fibo 优化 - 动态规划

#### 上台阶

#### 上台阶 优化 - 动态规划

### 栈模拟递归
#### 二叉树的前序遍历
#### 二叉树的后续遍历

### 尾调用

典型：

- [ ] 螺旋矩阵