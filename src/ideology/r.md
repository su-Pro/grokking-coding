## 递归

可以从三个层面来理解递归

-表现：函数调用自身
-实质：将问题范围进行逐渐减少，收敛的过程
-实现：什么是最小号问题（**base case**），如何将问题变成最小号问题（**recursion rule**）

### 前端相关
	
#### Array.prototype.reduce()
#### 深拷贝
#### 数组平拍
#### vuex

### 函数调用栈

- [ ] 动图

- [ ] 前端笔记 link 调用栈溢出

### 核心思想

#### 拆解过程（递归树向下）

- 把规模大的问题变成规模较小的同类型问题
- 规模较小的问题又不断变成规模更小的问题
- 规模小到一定程度可以直接得出它的解

#### 求解过程 （递归树向上）

- 由最小规模问题的解得出较大规模问题的解
- 由较大规模问题的解不断得出规模更大问题的解
- 最后得出原来问题的解

> 凡是可以利用上述思想解决问题的，都可以尝试使用递归

通常链表、二叉树的问题都可以利用递归思想来解决，因为这两个数据结构本身就是递归的结构：“套娃”。

### 逻辑细分

#### 明确函数的功能

不要去思考里面代码怎么写，首先搞清楚这个函数的干嘛用的

#### 明确原问题与子问题的关系

简单说就是在当前层做点什么事儿，能够将范围不断的缩减，最终缩减到最小号问题。

#### 明确base case

- 递归的过程中，子问题的规模在不断减小，当小到一定程度时可以直接得出它的解
- 寻找递basecase，相当于是思考这个问题：问题规模小到什么程度可以直接得出解？

#### [fibo](https://leetcode-cn.com/problems/fibonacci-number/)

斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

给定 N，计算 F(N)。

- 想求fibo（n）的值，就要求出前两项的值，再相加即可得到。于是可以将问题分解成fibo(n - 1) + fibo(n - 2)
- 求fibo(n - 1)的值，同样适用fibo（n）时的思想，于是可以将问题继续往下拆分。
- 当问题拆分到 n = 0 或者 n = 1时，就可以得到结果了（也就是最小号问题那一层的结果）
- 于是将最小号问题的结果不断返回，最终合并成当初的问题

```js
var fib = function(n) {
  if(n === 0) return 0  
  if(n === 1) return 1  
  return fib(n - 1) + fib(n - 2);
};
```

- [ ] 手画递归树的图

可以发现这个算法的时间复杂度为O(2 ^ n),其主要原因是存在**大量重复计算**。

#### fibo 优化 - 动态规划

```js
var fib = function(n) {
  let map = new Array(n + 1); 
  map[0] = 0
  map[1] = 1
  for(let i = 2;i <= n;i++){
    map[i] = map[i - 1] + map[i - 2]
  }
  return map[n]
};
```

### 栈模拟递归
#### 二叉树的前序遍历
#### 二叉树的后续遍历

### 尾调用

- 尾调用：一个函数的最后一个动作是调用函数
- 如果最后一个动作是调用自身，称为尾递归是尾调用的特殊情况
- 一些编译器能对尾调用进行优化，以达到节省栈空间的目的

不属于递归尾调用的例子：

```js
var fib = function(n) {
  if(n === 0) return 0  
  if(n === 1) return 1  
  return fib(n - 1) + fib(n - 2);
};
```

> 因为最后一个动作是将两个函数做加法

经过修改后，满足尾调用的要求：

```js
var fib = function(n) {
  helper(n,1,1)
  function helper(n,first,second) {
    if(n === 0) return 0  
    if(n === 1) return 1  
    return fib(n - 1,second,first + second)
  }
};
```

